package com.dbmansfield.book.app

import com.dbmansfield.book.Args
import com.dbmansfield.book.Library
import com.xenomachina.argparser.ArgParser
import com.xenomachina.argparser.ShowHelpException
import java.io.File

val program = "bookmanager"
val homeDir: String = System.getProperty("user.home")
val libraryDir = "${System.getenv("XDG_DATA_HOME") ?: homeDir}/$program"

// The help formatter includes options we don't want to list, like
// --gapplication-service. This was generated by the ruby gem slop,
// which also looks much nicer I think.
val help = """Usage: $program [OPTION]... COMMAND [ARGS]...
Manage a library of digital books and papers.

    -h, --help     display this help and exit
    -l, --library  name of the library
"""

fun main(vararg args: String) {
    // Parse the arguments
    val parsedArgs: Args = try {
        Args(ArgParser(args))
    } catch (e: ShowHelpException) {
        println(help)
        return
    }

    // --library
    val libraryFilename = if (parsedArgs.library.isNotBlank()) {
        parsedArgs.library
    } else {
        "library.yml"
    }

    // Load library
    val library = try {
        File(libraryDir).mkdir()
        Library.findLibrary("$libraryDir/$libraryFilename")
    } catch (e: Exception) {
        println(e)
        return
    }

    // Run as a DBus Service
    if (parsedArgs.service) {
        runService(library)
        return
    }

    // Command positional argument is not compulsory because it doesn't need
    // to be given when invoking as a DBus service. It is compulsory when
    // invoked normally, however
    if (parsedArgs.terms.isEmpty()) {
        println("No command given")
        println(help)
        return
    }

    // Parse and execute command
    CommandParser(library).parse(parsedArgs.terms)
}